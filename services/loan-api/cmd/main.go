package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"

	"loan-api/application"
	_ "loan-api/docs" // This is generated by swag
	"loan-api/domain"
	"loan-api/infrastructure/database/postgres"
	"loan-api/infrastructure/workflow"
	"loan-api/interfaces"
	"loan-api/interfaces/middleware"
	"loan-api/pkg/config"
	"loan-api/pkg/i18n"
)

// @title           Loan Service API
// @version         1.0
// @description     A comprehensive loan origination service with internationalization support for Vietnamese and English, featuring Netflix Conductor workflow integration. The API provides comprehensive error responses with detailed validation information including human-readable error messages, field-specific error details, validation error context, and structured error metadata for programmatic error handling.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @tag.name Applications
// @tag.description Loan application management operations

// @tag.name Pre-qualification
// @tag.description Loan pre-qualification operations

// @tag.name Offers
// @tag.description Loan offer management operations

// @tag.name Admin
// @tag.description Administrative operations

// @tag.name Health
// @tag.description Health check operations

// @tag.name Error Handling
// @tag.description Comprehensive error handling with detailed validation information

func main() {
	// Load configuration
	cfg, err := config.LoadConfig("config/config.yaml")
	if err != nil {
		panic(fmt.Sprintf("Failed to load configuration: %v", err))
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		panic(fmt.Sprintf("Invalid configuration: %v", err))
	}

	// Initialize logger
	logger, err := initLogger(cfg)
	if err != nil {
		panic(fmt.Sprintf("Failed to initialize logger: %v", err))
	}
	defer logger.Sync()

	logger.Info("Starting loan API service",
		zap.String("version", cfg.Application.Version),
		zap.String("environment", cfg.Application.Environment),
		zap.Int("port", cfg.Server.Port),
	)

	// Initialize i18n
	localizer, err := initI18n()
	if err != nil {
		logger.Fatal("Failed to initialize i18n", zap.Error(err))
	}

	// Initialize database connection
	dbConfig := &postgres.Config{
		Host:            cfg.Database.Host,
		Port:            strconv.Itoa(cfg.Database.Port),
		User:            cfg.Database.User,
		Password:        cfg.Database.Password,
		Database:        cfg.Database.Name,
		SSLMode:         cfg.Database.SSLMode,
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: 5 * time.Minute,
	}

	dbConnection, err := postgres.NewConnection(dbConfig, logger)
	if err != nil {
		logger.Fatal("Failed to connect to database", zap.Error(err))
	}
	defer dbConnection.Close()

	// Initialize repositories with real database implementation
	dbFactory := postgres.NewFactory(dbConnection, logger)
	userRepo := dbFactory.GetUserRepository()
	loanRepo := dbFactory.GetLoanRepository()

	// Initialize workflow orchestrator with real Conductor client
	conductorClient := workflow.NewConductorClientImpl(
		cfg.Conductor.BaseURL,
		logger,
	)
	workflowOrchestrator := workflow.NewLoanWorkflowOrchestrator(conductorClient, logger, localizer)

	loanService := application.NewLoanService(userRepo, loanRepo, workflowOrchestrator, logger, localizer)
	loanHandler := interfaces.NewLoanHandler(loanService, logger, localizer)

	// Setup HTTP server
	router := setupRouter(logger, localizer, loanHandler)

	server := &http.Server{
		Addr:         cfg.GetServerAddr(),
		Handler:      router,
		ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
	}

	// Start server in a goroutine
	go func() {
		logger.Info("Starting HTTP server",
			zap.String("addr", server.Addr),
		)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatal("Failed to start server", zap.Error(err))
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Info("Shutting down server...")

	// Graceful shutdown
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.Server.GracefulShutdownTimeout)*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		logger.Error("Server forced to shutdown", zap.Error(err))
	}

	logger.Info("Server exited")
}

// initLogger initializes the zap logger
func initLogger(cfg *config.Config) (*zap.Logger, error) {
	var level zapcore.Level
	switch cfg.Logging.Level {
	case "debug":
		level = zapcore.DebugLevel
	case "info":
		level = zapcore.InfoLevel
	case "warn":
		level = zapcore.WarnLevel
	case "error":
		level = zapcore.ErrorLevel
	default:
		level = zapcore.InfoLevel
	}

	zapConfig := zap.Config{
		Level:       zap.NewAtomicLevelAt(level),
		Development: cfg.IsDevelopment(),
		Sampling: &zap.SamplingConfig{
			Initial:    100,
			Thereafter: 100,
		},
		Encoding: cfg.Logging.Format,
		EncoderConfig: zapcore.EncoderConfig{
			TimeKey:        "timestamp",
			LevelKey:       "level",
			NameKey:        "logger",
			CallerKey:      "caller",
			FunctionKey:    zapcore.OmitKey,
			MessageKey:     "message",
			StacktraceKey:  "stacktrace",
			LineEnding:     zapcore.DefaultLineEnding,
			EncodeLevel:    zapcore.LowercaseLevelEncoder,
			EncodeTime:     zapcore.ISO8601TimeEncoder,
			EncodeDuration: zapcore.SecondsDurationEncoder,
			EncodeCaller:   zapcore.ShortCallerEncoder,
		},
		OutputPaths:      []string{"stdout"},
		ErrorOutputPaths: []string{"stderr"},
		InitialFields: map[string]interface{}{
			"service": cfg.Application.Name,
			"version": cfg.Application.Version,
		},
	}

	return zapConfig.Build()
}

// initI18n initializes the internationalization
func initI18n() (*i18n.Localizer, error) {
	return i18n.NewLocalizer()
}

// setupRouter sets up the Gin router with middleware and routes
func setupRouter(logger *zap.Logger, localizer *i18n.Localizer, loanHandler *interfaces.LoanHandler) *gin.Engine {
	// Set Gin mode
	gin.SetMode(gin.ReleaseMode)

	router := gin.New()

	// Add middleware
	router.Use(gin.Recovery())
	router.Use(middleware.RequestIDMiddleware())
	router.Use(corsMiddleware())
	router.Use(loggerMiddleware(logger))

	// Add i18n middleware
	i18nMiddleware := middleware.NewI18nMiddleware(localizer, logger)
	router.Use(i18nMiddleware.Handler())

	// Swagger documentation route
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Register routes
	v1 := router.Group("/v1")
	loanHandler.RegisterRoutes(v1)

	return router
}

// corsMiddleware handles CORS
func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Credentials", "true")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With, X-Language, X-Request-ID")
		c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

// loggerMiddleware logs HTTP requests
func loggerMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return gin.LoggerWithWriter(gin.DefaultWriter)
}
