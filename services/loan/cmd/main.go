package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"

	"loan-service/application"
	_ "loan-service/docs" // This is generated by swag
	"loan-service/domain"
	"loan-service/infrastructure/database/postgres"
	"loan-service/infrastructure/workflow"
	"loan-service/interfaces"
	"loan-service/interfaces/middleware"
	"loan-service/pkg/config"
	"loan-service/pkg/i18n"
)

// @title           Loan Service API
// @version         1.0
// @description     A comprehensive loan origination service with internationalization support for Vietnamese and English, featuring Netflix Conductor workflow integration. The API provides comprehensive error responses with detailed validation information including human-readable error messages, field-specific error details, validation error context, and structured error metadata for programmatic error handling.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @tag.name Applications
// @tag.description Loan application management operations

// @tag.name Pre-qualification
// @tag.description Loan pre-qualification operations

// @tag.name Offers
// @tag.description Loan offer management operations

// @tag.name Admin
// @tag.description Administrative operations

// @tag.name Health
// @tag.description Health check operations

// @tag.name Error Handling
// @tag.description Comprehensive error handling with detailed validation information

// AppConfig holds the application configuration (legacy, will be removed)
type AppConfig struct {
	Server struct {
		Port         string `env:"PORT" envDefault:"8080"`
		Host         string `env:"HOST" envDefault:"0.0.0.0"`
		ReadTimeout  int    `env:"READ_TIMEOUT" envDefault:"30"`
		WriteTimeout int    `env:"WRITE_TIMEOUT" envDefault:"30"`
	}
	Database struct {
		Host     string `env:"DB_HOST" envDefault:"localhost"`
		Port     string `env:"DB_PORT" envDefault:"5432"`
		User     string `env:"DB_USER" envDefault:"postgres"`
		Password string `env:"DB_PASSWORD" envDefault:"password"`
		Name     string `env:"DB_NAME" envDefault:"loan_service"`
		SSLMode  string `env:"DB_SSLMODE" envDefault:"disable"`
	}
	Conductor struct {
		BaseURL string `env:"CONDUCTOR_BASE_URL" envDefault:"http://localhost:8080"`
		Timeout int    `env:"CONDUCTOR_TIMEOUT" envDefault:"30"`
	}
	Logging struct {
		Level  string `env:"LOG_LEVEL" envDefault:"info"`
		Format string `env:"LOG_FORMAT" envDefault:"json"`
	}
}

// PlaceholderUserRepository is a placeholder implementation for user data
type PlaceholderUserRepository struct {
	logger *zap.Logger
}

// CreateUser creates a user (placeholder implementation)
func (r *PlaceholderUserRepository) CreateUser(ctx context.Context, user *domain.User) (string, error) {
	r.logger.Error("CreateUser not implemented - database repository required")
	return "", fmt.Errorf("database repository not implemented")
}

// GetUserByID returns a user by ID (placeholder implementation)
func (r *PlaceholderUserRepository) GetUserByID(ctx context.Context, id string) (*domain.User, error) {
	r.logger.Error("GetUserByID not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

// GetUserByEmail returns a user by email (placeholder implementation)
func (r *PlaceholderUserRepository) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) {
	r.logger.Error("GetUserByEmail not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

// UpdateUser updates a user (placeholder implementation)
func (r *PlaceholderUserRepository) UpdateUser(ctx context.Context, user *domain.User) error {
	r.logger.Error("UpdateUser not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

// DeleteUser deletes a user (placeholder implementation)
func (r *PlaceholderUserRepository) DeleteUser(ctx context.Context, id string) error {
	r.logger.Error("DeleteUser not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

// PlaceholderRepository is a placeholder implementation for development
type PlaceholderRepository struct {
	logger *zap.Logger
}

func NewPlaceholderRepository(logger *zap.Logger) *PlaceholderRepository {
	return &PlaceholderRepository{logger: logger}
}

func (r *PlaceholderRepository) CreateApplication(ctx context.Context, app *domain.LoanApplication) error {
	r.logger.Error("CreateApplication not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) GetApplicationByID(ctx context.Context, id string) (*domain.LoanApplication, error) {
	r.logger.Error("GetApplicationByID not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) GetApplicationsByUserID(ctx context.Context, userID string) ([]*domain.LoanApplication, error) {
	r.logger.Error("GetApplicationsByUserID not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) UpdateApplication(ctx context.Context, app *domain.LoanApplication) error {
	r.logger.Error("UpdateApplication not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) DeleteApplication(ctx context.Context, id string) error {
	r.logger.Error("DeleteApplication not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) CreateOffer(ctx context.Context, offer *domain.LoanOffer) error {
	r.logger.Error("CreateOffer not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) GetOfferByApplicationID(ctx context.Context, applicationID string) (*domain.LoanOffer, error) {
	r.logger.Error("GetOfferByApplicationID not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) UpdateOffer(ctx context.Context, offer *domain.LoanOffer) error {
	r.logger.Error("UpdateOffer not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) CreateStateTransition(ctx context.Context, transition *domain.StateTransition) error {
	r.logger.Error("CreateStateTransition not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) GetStateTransitions(ctx context.Context, applicationID string) ([]*domain.StateTransition, error) {
	r.logger.Error("GetStateTransitions not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) SaveWorkflowExecution(ctx context.Context, execution *domain.WorkflowExecution) error {
	r.logger.Error("SaveWorkflowExecution not implemented - database repository required")
	return fmt.Errorf("database repository not implemented")
}

func (r *PlaceholderRepository) GetWorkflowExecutionByApplicationID(ctx context.Context, applicationID string) (*domain.WorkflowExecution, error) {
	r.logger.Error("GetWorkflowExecutionByApplicationID not implemented - database repository required")
	return nil, fmt.Errorf("database repository not implemented")
}

func main() {
	// Load configuration
	cfg, err := config.LoadConfig("config/config.yaml")
	if err != nil {
		panic(fmt.Sprintf("Failed to load configuration: %v", err))
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		panic(fmt.Sprintf("Invalid configuration: %v", err))
	}

	// Initialize logger
	logger, err := initLogger(cfg)
	if err != nil {
		panic(fmt.Sprintf("Failed to initialize logger: %v", err))
	}
	defer logger.Sync()

	logger.Info("Starting loan service",
		zap.String("version", cfg.Application.Version),
		zap.String("environment", cfg.Application.Environment),
		zap.Int("port", cfg.Server.Port),
	)

	// Initialize i18n
	localizer, err := initI18n()
	if err != nil {
		logger.Fatal("Failed to initialize i18n", zap.Error(err))
	}

	// Initialize database connection
	dbConfig := &postgres.Config{
		Host:            cfg.Database.Host,
		Port:            strconv.Itoa(cfg.Database.Port),
		User:            cfg.Database.User,
		Password:        cfg.Database.Password,
		Database:        cfg.Database.Name,
		SSLMode:         cfg.Database.SSLMode,
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: 5 * time.Minute,
	}

	dbConnection, err := postgres.NewConnection(dbConfig, logger)
	if err != nil {
		logger.Fatal("Failed to connect to database", zap.Error(err))
	}
	defer dbConnection.Close()

	// Initialize repositories with real database implementation
	dbFactory := postgres.NewFactory(dbConnection, logger)
	userRepo := dbFactory.GetUserRepository()
	loanRepo := dbFactory.GetLoanRepository()

	// Initialize workflow orchestrator with real Conductor client
	conductorClient := workflow.NewConductorClientImpl(
		cfg.Conductor.BaseURL,
		logger,
	)
	workflowOrchestrator := workflow.NewLoanWorkflowOrchestrator(conductorClient, logger, localizer)

	// Initialize and start task worker with repository
	taskWorker := workflow.NewTaskWorkerWithRepository(conductorClient, logger, localizer, loanRepo)

	// Start task worker in a goroutine
	go func() {
		logger.Info("Starting task worker")
		if err := taskWorker.Start(context.Background()); err != nil {
			logger.Error("Task worker stopped with error", zap.Error(err))
		}
	}()

	loanService := application.NewLoanService(userRepo, loanRepo, workflowOrchestrator, logger, localizer)
	loanHandler := interfaces.NewLoanHandler(loanService, logger, localizer)

	// Setup HTTP server
	router := setupRouter(logger, localizer, loanHandler)

	server := &http.Server{
		Addr:         cfg.GetServerAddr(),
		Handler:      router,
		ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
	}

	// Start server in a goroutine
	go func() {
		logger.Info("Starting HTTP server",
			zap.String("addr", server.Addr),
		)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatal("Failed to start server", zap.Error(err))
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Info("Shutting down server...")

	// Graceful shutdown
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.Server.GracefulShutdownTimeout)*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		logger.Error("Server forced to shutdown", zap.Error(err))
	}

	logger.Info("Server exited")
}

// loadConfig loads configuration from environment variables (legacy function)
func loadConfig() *AppConfig {
	config := &AppConfig{}

	// Set defaults (in production, use a proper config library like viper)
	config.Server.Port = getEnv("PORT", "8080")
	config.Server.Host = getEnv("HOST", "0.0.0.0")
	config.Database.Host = getEnv("DB_HOST", "localhost")
	config.Database.Port = getEnv("DB_PORT", "5432")
	config.Database.User = getEnv("DB_USER", "postgres")
	config.Database.Password = getEnv("DB_PASSWORD", "password")
	config.Database.Name = getEnv("DB_NAME", "loan_service")
	config.Database.SSLMode = getEnv("DB_SSLMODE", "disable")
	config.Conductor.BaseURL = getEnv("CONDUCTOR_BASE_URL", "http://localhost:8082")
	config.Logging.Level = getEnv("LOG_LEVEL", "info")
	config.Logging.Format = getEnv("LOG_FORMAT", "json")

	return config
}

// initLogger initializes the zap logger
func initLogger(cfg *config.Config) (*zap.Logger, error) {
	var level zapcore.Level
	switch cfg.Logging.Level {
	case "debug":
		level = zapcore.DebugLevel
	case "info":
		level = zapcore.InfoLevel
	case "warn":
		level = zapcore.WarnLevel
	case "error":
		level = zapcore.ErrorLevel
	default:
		level = zapcore.InfoLevel
	}

	zapConfig := zap.Config{
		Level:       zap.NewAtomicLevelAt(level),
		Development: cfg.IsDevelopment(),
		Sampling: &zap.SamplingConfig{
			Initial:    100,
			Thereafter: 100,
		},
		Encoding: cfg.Logging.Format,
		EncoderConfig: zapcore.EncoderConfig{
			TimeKey:        "timestamp",
			LevelKey:       "level",
			NameKey:        "logger",
			CallerKey:      "caller",
			FunctionKey:    zapcore.OmitKey,
			MessageKey:     "message",
			StacktraceKey:  "stacktrace",
			LineEnding:     zapcore.DefaultLineEnding,
			EncodeLevel:    zapcore.LowercaseLevelEncoder,
			EncodeTime:     zapcore.ISO8601TimeEncoder,
			EncodeDuration: zapcore.SecondsDurationEncoder,
			EncodeCaller:   zapcore.ShortCallerEncoder,
		},
		OutputPaths:      []string{"stdout"},
		ErrorOutputPaths: []string{"stderr"},
		InitialFields: map[string]interface{}{
			"service": cfg.Application.Name,
			"version": cfg.Application.Version,
		},
	}

	return zapConfig.Build()
}

// initI18n initializes the internationalization
func initI18n() (*i18n.Localizer, error) {
	return i18n.NewLocalizer()
}

// setupRouter sets up the Gin router with middleware and routes
func setupRouter(logger *zap.Logger, localizer *i18n.Localizer, loanHandler *interfaces.LoanHandler) *gin.Engine {
	// Set Gin mode
	gin.SetMode(gin.ReleaseMode)

	router := gin.New()

	// Add middleware
	router.Use(gin.Recovery())
	router.Use(middleware.RequestIDMiddleware())
	router.Use(corsMiddleware())
	router.Use(loggerMiddleware(logger))

	// Add i18n middleware
	i18nMiddleware := middleware.NewI18nMiddleware(localizer, logger)
	router.Use(i18nMiddleware.Handler())

	// TODO: Add real authentication middleware
	// router.Use(authMiddleware())

	// Swagger documentation route
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Register routes
	v1 := router.Group("/v1")
	loanHandler.RegisterRoutes(v1)

	return router
}

// corsMiddleware handles CORS
func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Credentials", "true")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With, X-Language, X-Request-ID")
		c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

// loggerMiddleware logs HTTP requests
func loggerMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return gin.LoggerWithWriter(gin.DefaultWriter)
}

// TODO: Implement real authentication middleware
// func authMiddleware() gin.HandlerFunc {
// 	return func(c *gin.Context) {
// 		// Validate JWT tokens and extract user info
// 		// Set user context for downstream handlers
// 		c.Next()
// 	}
// }

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
